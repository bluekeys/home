#+TITLE: Emacs Config
#+PROPERTY: header-args            :noweb no-export :comments both :results silent :mkdirp no 
#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/init.el 

* Lots and lots of ideas were taken from elsewhere.
https://github.com/raxod502/radian
https://countvajhula.com/2020/12/27/turn-your-emacs-d-into-an-emacs-distribution-with-straight-el/
https://en.liujiacai.net/2021/05/21/emacs-package/
http://vimdoc.sourceforge.net/htmldoc/vimindex.html#g
https://wikemacs.org/wiki/Discoverability#Hercules.2C_joining_which-key-mode_and_Hydras
http://trey-jackson.blogspot.com/2010/04/emacs-tip-36-abort-minibuffer-when.html
* A explanation of how it all works
Distraction-free, goal-driven, task-oriented.
I would like to see that work is driven by org mode.
Actionable items will be grouped by projects.
A timeline with milestones.
Each project will have a top-level README.md which will contain project planning and other documentation, written in a "literate" style.
When working on a TODO item in a project, a perspective should be created. Org's clock should be started. Switching perspectives should pause the clock on the current TODO and start the clock on the new item.

The use of perspectives in this way should help roll-up all the tasks created by a "yak shaving" expedition, particularly when perspectives are sorted by created.

The README document in each project should contain a backlog heading.

E.g. I have an idea, I want to ensure that posframes are used for all hydras. I want to ensure that all text is visible in all hydras, which in the case of C-h, doesn't appear to be true. I also want to ensure that the C-spc / spc hydra is a posframe.

I should record the ideas, using org-capture. I should then refile those ideas into the relevant areas of the config.

To aid debugging, each top level headline is configured to tangle into a distinct lisp file. Those files can then be loaded (or not) from init.el.

* Early init
#+begin_src emacs-lisp :tangle ~/.emacs.d/early-init.el
  (setq package-enable-at-startup nil) ;; Recommended by straight.el to prevent package.el loading packages prior to their init-file loading
#+end_src
** Free as much screen real-estate as possible
It's fine, the tooltip can stay, it'll display in the echo area.
#+begin_src emacs-lisp
  (tooltip-mode t)
#+end_src
I don't need scrollbars, I have nyan mode
#+begin_src emacs-lisp
  (scroll-bar-mode -1)
#+end_src
Bye bye pretty button bar, I prefer M-`
#+begin_src emacs-lisp
  (tool-bar-mode -1)
#+end_src
As above
#+begin_src emacs-lisp
  (menu-bar-mode 0) ; so long file -> menu
#+end_src
** Taken from "The modern emacs"
#+begin_src emacs-lisp
  (push '(menu-bar-lines . 0) default-frame-alist)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)
  (push '(internal-border-width . 0) default-frame-alist)

  (setq-default fringes-outside-margins t)
  (setq-default left-margin-width 1)
  (setq-default left-margin-width 1)

  (setq use-dialog-box nil)
  (setq use-file-dialog nil)
  (setq inhibit-startup-screen t)

  ;(setq-default header-line-format mode-line-format)
  ;(setq-default mode-line-format nil)
#+end_src

* Initialise!
#+begin_src emacs-lisp
  (defvar my/org-roam-directory "~/roam")
  (defvar my/org-roam-dailies-directory "~/roam/daily")
  (defvar my/org-roam-templates-directory "~/roam/Templates")
  (defvar my/major-mode-key "'")
  (defvar my/leader-key "#")
#+end_src

** Stop custom
Custom is manageable using use-package, and I just plain don't like it, because it writes itself by default to my init file.

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
#+end_src

** UTF8 everywhere
Set up unicode all the time.
#+begin_src emacs-lisp
  (prefer-coding-system       'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)

  (setq default-buffer-file-coding-system 'utf8)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+end_src

** COMMENT recentf - Keep track of recently opened files
Recentf is a minor mode that builds a list of recently opened files. This list is is automatically saved across sessions on exiting Emacs - you can then access this list through a command or the menu.

#+begin_src emacs-lisp
  (require 'recentf)
  (add-to-list 'recentf-exclude no-littering-var-directory)
  (add-to-list 'recentf-exclude no-littering-etc-directory)
  (setq recentf-auto-cleanup 'never) ;; disable before we start recentf!
  (recentf-mode 1)
  (setq recentf-max-menu-items 100)
  (setq recentf-max-saved-items 100)
  (global-set-key "\C-x\ \C-r" 'recentf-open-files)
  (run-at-time nil (* 5 60) 'recentf-save-list)
#+end_src

* straight.el - A functional package manager
https://github.com/raxod502/straight.el
You must install git to use straight.el
You must remove any code that relates to package.el, therefore you must remove any use-package :ensure / use-package-always-ensure

** Stop package.el
Prevent package.el from modifying this file, because straight.el is doing the work.

#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
#+end_src

** Variables that need setting before bootstrap
Because I modify all my repos in emacs anyways and they're stored in ~/.emacs.d/straight/repos, I can probably get away with only checking for modifications on save.

#+begin_src emacs-lisp
  (when
      (eq window-system 'x)
      (setq straight-check-for-modifications '(check-on-save)))
#+end_src

Configure use-package to prefer straight, which allows me to get rid of the abundance of :straight t's that were littering my config.

#+begin_src emacs-lisp
  (setq straight-use-package-by-default t)
#+end_src

Setting the variable straight-cache-autoloads causes the autoloads of all used packages to be cached in a single file.
You may wish to call straight-prune-build occasionally otherwise the file may grow large over time.

#+begin_src emacs-lisp
  (setq straight-cache-autoloads t)
#+end_src

Straight reports process output to its buffer, I'm normally just not interested, so I add a space to the beginning of its name to hide it from view.

#+begin_src emacs-lisp
  (setq straight-process-buffer " *straight-process*")
#+end_src

** Bootstrap code
This is taken verbatim from the site.

#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

** use-package - Declarative package configuration and loading
use-package loads features, not packages. Features can be tested for using featurep.

Use the :init keyword to execute code before a package is loaded.

Similarly, :config can be used to execute code after a package is loaded. In cases where loading is done lazily (see more about autoloading below), this execution is deferred until after the autoload occurs: 

https://github.com/jwiegley/use-package

While use-package can often seem like magic, you can demystify it by placing a point after a use-package stanza and doing M-x pp-macroexpand-last-sexp.

https://emacs.stackexchange.com/questions/61276/why-does-use-package-considers-emacs-as-a-package

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
#+end_src

* restart-emacs - Make restarting emacs just work!
This is a simple, convenience wrapper around functions to restart emacs. In a terminal, on windows, wherever, this package has us covered.

#+begin_src emacs-lisp
  (use-package restart-emacs :delight) 
#+end_src

* no-littering - Don't litter!
https://github.com/emacscollective/no-littering

#+begin_src emacs-lisp
  (use-package no-littering
    :config
    (setq auto-save-file-name-transforms
          `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))))
#+end_src

* Key bindings (hydra, hercules, key chords, general)
Use M-x describe-personal-keybindings to see keybindings set by init.el
https://www.masteringemacs.org/article/mastering-key-bindings-emacs
** Evil
Imitate vi / vim, mainly for movement and because of muscle memory or ergonomics
For more information about this package, see https://github.com/noctuid/evil-guide
#+begin_src emacs-lisp
  (use-package evil
    :delight
    :config
    (evil-mode 1))
#+end_src

*** COMMENT Some modes should always begin in evil-emacs state
#+begin_src emacs-lisp
  (defun my/modes-that-start-in-emacs-state-hook () ;; TODO If i do go into insert mode, esc should return to emacs mode instead of normal mode
    (dolist (mode '(eshell-mode
                    git-rebase-mode
                    erc-mode 
                    term-mode))
      (add-to-list 'evil-emacs-state-modes mode)))
#+end_src

*** evil-multiedit
For more information about this package, see https://github.com/hlissner/evil-multiedit
#+begin_src emacs-lisp
  (use-package evil-multiedit :delight :after (evil) :config (evil-multiedit-default-keybinds))
#+end_src
**** TODO FIXME Warning (iedit): Iedit default key "C-;" is occupied by embark-dwim.

*** undo-tree
For more information about this package, see https://elpa.gnu.org/packages/undo-tree.html
#+begin_src emacs-lisp
  (use-package undo-tree :delight :after (evil))
#+end_src

*** evil-cleverparens
Paredit with evil awareness for more than just lisp
#+begin_src emacs-lisp
  (use-package evil-cleverparens :after (evil))
#+end_src

*** Get ESC to behave consistently
#+begin_src emacs-lisp
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+end_src

** General - For single key presses
- [ ] Pressing enter on any kind of link, should follow the link, in another window

This library plays well with evil and use-package
#+begin_src emacs-lisp
  (use-package general 
    :delight
    :config 
    (general-evil-setup t)

    (general-create-definer my-leader-def :prefix my/leader-key)
    ; This feels more comfortable to me than the emacs defaults
    (mmap "M-j" 'scroll-other-window)
    (mmap "M-k" 'scroll-other-window-down)

    (with-eval-after-load 'hydra
      (with-eval-after-load 'all-the-icons
        (defvar my/hydra-leader--title (s-concat (all-the-icons-faicon "magic" "Leader" 0 0) " : Magic menu"))

        (general-def :states '(normal motion) my/leader-key 'my/hydra-leader/body))))
#+end_src
** Hydra - For things that are just so great, you want to keep doing them - hydra
https://rski.github.io/emacs/hydra/2017/04/08/a-case-for-hydra.html
https://github.com/abo-abo/hydra/wiki
https://oremacs.com/2015/01/20/introducing-hydra/

It helps me to think of a hydra function as a vim mode.
#+begin_src emacs-lisp
  (use-package hydra :delight)
#+end_src

*** Pretty Hydras
https://github.com/jerrypnz/major-mode-hydra.el#pretty-hydra

Pretty hydras is included with the major-mode-hydras feature.
Similar to the :mode-hydra keyword above, you can use :pretty-hydra keyword in use-package to create pretty hydras with commands autoloaded. 
Like :mode-hydra, it also supports omitting name and/or body. When the name is omitted, it defaults to <package>-hydra. 

*** Major Mode Hydras
https://github.com/jerrypnz/major-mode-hydra.el
As I use use-package, I can use the :mode-hydra keyword to create major mode hydras. 
#+begin_src emacs-lisp
  (use-package major-mode-hydra
    :demand t ; without this, :major-mode won't reliably work for use-package definitions
    :custom
    (major-mode-hydra-invisible-quit-key "SPC") 
    (major-mode-hydra-title-generator
        '(lambda (mode)
           (s-concat "\n"
                     (s-repeat 10 " ")
                     (all-the-icons-icon-for-mode mode :v-adjust 0.05)
                     " "
                     (symbol-name mode)
                     " commands")))
    :init (general-def :states '(normal motion) my/major-mode-key 'major-mode-hydra))
#+end_src

*** Some hydra definitions
Hydra definitions will be in 1 of 2 places. Here, or the respective mode use-package declaration.
**** Misc
This is a catch all column.
#+begin_src emacs-lisp
  (with-eval-after-load 'hydra
    (with-eval-after-load 'major-mode-hydra
      (message "Adding a shortcut column to my leader hydra")
      (pretty-hydra-define+ my/hydra-leader ()
        ("Tools"
         ()
         "Misc"
         (("d" dired "Dired" :color blue)
          ("H" (find-file "~/Projects/home/emacs.org") "emacs.org" :color blue))
         "Roam"
         (("j" my/hydra-roam-dailies/body "Roam dailies map" :color blue)
          ("J" org-roam-dailies-goto-today "Goto journal" :color blue)
          ("g" org-roam-insert "Insert" :color blue)
          ("g" org-roam-graph "Graph" :color blue)
          ("c" org-roam-capture "Capture" :color blue)
          ("f" org-roam-node-find "Find" :color blue))))))
#+end_src

#+begin_src emacs-lisp
  (defhydra my/hydra-roam-dailies (:color blue)
    "Daily journal"
    ("n" org-roam-dailies-capture-today "Today" :column "Capture")
    ("v" org-roam-dailies-capture-date "Date" :column "Capture")
    ("d" org-roam-dailies-goto-today "Today" :column "Goto" :color pink)
    ("f" org-roam-dailies-goto-next-note "Next note" :column "Goto" :color pink)
    ("b" org-roam-dailies-goto-previous-note "Previous note" :column "Goto" :color pink)
    ("t" org-roam-dailies-goto-tomorrow "Tomorrow" :column "Goto" :color pink)
    ("y" org-roam-dailies-goto-yesterday "Yesterday" :column "Goto" :color pink)
    ("." org-roam-dailies-find-directory "Dailies dir" :column "Goto")
    ("c" org-roam-dailies-goto-date "Date" :column "Goto")
  )

#+end_src

**** UI
#+begin_src emacs-lisp :noweb-ref hydra-text-scale
  (with-eval-after-load 'hydra
    (message "Defining hydra - text scale")
    (defhydra my/hydra-text-scale (:color cyan :quit-key "SPC")
      "scale text"
      ("j" text-scale-increase "in")
      ("k" text-scale-decrease "out"))

    (with-eval-after-load 'major-mode-hydra
      (message "Attaching hydra to leader - text scale")
      (pretty-hydra-define+ my/hydra-leader ()
        ("Misc" (("s" (my/hydra-text-scale/body) "scale text" :color blue))))))
#+end_src

**** Straight
#+begin_src emacs-lisp :noweb-ref hydra-straight-helper
  (with-eval-after-load 'hydra
    (message "Defining straight helper hydra")
    (defhydra hydra-straight-helper (:hint nil)
      "
      _c_heck all       |_f_etch all     |_m_erge all      |_n_ormalize all   |p_u_sh all
      _C_heck package   |_F_etch package |_M_erge package  |_N_ormlize package|p_U_sh package
      ----------------^^+--------------^^+---------------^^+----------------^^+------------||_q_uit||
      _r_ebuild all     |_p_ull all      |_v_ersions freeze|_w_atcher start   |_g_et recipe
      _R_ebuild package |_P_ull package  |_V_ersions thaw  |_W_atcher quit    |prun_e_ build"
      ("c" straight-check-all)
      ("C" straight-check-package)
      ("r" straight-rebuild-all)
      ("R" straight-rebuild-package)
      ("f" straight-fetch-all)
      ("F" straight-fetch-package)
      ("p" straight-pull-all)
      ("P" straight-pull-package)
      ("m" straight-merge-all)
      ("M" straight-merge-package)
      ("n" straight-normalize-all)
      ("N" straight-normalize-package)
      ("u" straight-push-all)
      ("U" straight-push-package)
      ("v" straight-freeze-versions)
      ("V" straight-thaw-versions)
      ("w" straight-watcher-start)
      ("W" straight-watcher-quit)
      ("g" straight-get-recipe)
      ("e" straight-prune-build)
      ("q" nil))

    (with-eval-after-load 'major-mode-hydra
      (message "Attaching hydra to leader - straight")
      (pretty-hydra-define+ my/hydra-leader ()
        ("Tools" (("S" (hydra-straight-helper/body) "Straight" :color blue))))))
#+end_src
**** Global org-mode
#+begin_src emacs-lisp
  (with-eval-after-load 'hydra
    (message "Defining hydra - global org mode")
    (defhydra hydra-global-org (:color blue :hint nil)
      "
    Timer^^        ^Clock^         ^Capture^       ^Document^
    ----------------------------------------------------------
    s_t_art        _W_ clock in    _c_apture       _o_ overview
     _s_top        _O_ clock out   _l_ast capture
    _r_eset        _J_ clock goto
    _p_rint
    "
      ("t" org-timer-start)
      ("s" org-timer-stop)
      ;; Need to be at timer
      ("r" org-timer-set-timer)
      ;; Print timer value to buffer
      ("p" org-timer)
      ("W" (org-clock-in '(4)))
      ("O" org-clock-out)
      ;; Visit the clocked task from any buffer
      ("J" org-clock-goto)
      ("c" org-capture)
      ("l" org-capture-goto-last-stored)
      ("o" org-overview))

    (with-eval-after-load 'major-mode-hydra
      (message "Attaching hydra to leader - global org mode")
      (pretty-hydra-define+ my/hydra-leader ()
        ("Misc"
         (("o" (hydra-global-org/body) "Org" :color blue))))))
#+end_src
**** Help
This is an area that I have underexplored and look forward to unlocking more of the potential of in the future.
#+begin_src emacs-lisp
  (with-eval-after-load 'all-the-icons
    (message "Defining hydra - help")
    (defvar my/help--title (all-the-icons-faicon "medkit" "Help" 1 -0.05))
                                          ; C-;     iedit-mode-toggle-on-function
    (pretty-hydra-define+ my/help (:foreign-keys warn :title my/help--title :quit-key "SPC")
      ("Help"
       (("H" help-for-help "Help for help")
        ("a" apropos-command)
        ("d" apropos-documentation)
        ("e" view-echo-area-messages)
        ("l" view-lossage))

       "Info"
       (("i" info)
        ("4" info-other-window "Info other window")
        ("K" Info-goto-emacs-key-command-node)
        ("F" Info-goto-emacs-command-node "Goto info node for command")
        ("S" info-lookup-symbol))

       "Help at point - something specific, normally with a default"
       (("c" describe-coding-system "Describe coding system")
        ("D" describe-input-method "Describe input method")
        ("c" describe-key-briefly)
        ("b" describe-bindings)
        ("f" describe-function)
        ("w" where-is "Find where something's bound")
        ("k" describe-key)
        ("m" describe-mode)
        ("o" describe-symbol)
        ("v" describe-variable)
        ("f" helpful-callable "callable")
        ("v" helpful-variable "variable")
        ("k" helpful-key "key")
        ("x" xref-find-definitions "Jump to definition")
        ("c" helpful-command "command")
        ("." helpful-at-point "thing at point")
        ("d" display-local-help "Get help at point"))))

    (message "Attaching hydra to leader - help")
    (pretty-hydra-define+ my/hydra-leader ()
      ("Misc"
       (("h" (my/help/body) "Help" :color blue)))))
#+end_src
***** Help for emacs
#+begin_src emacs-lisp
  (with-eval-after-load 'all-the-icons
    (message "Defining hydra - help - gnu emacs")
    (defvar my/help-gnu--title (all-the-icons-fileicon "emacs" "Help - Gnu Emacs" 1 -0.05))

    (pretty-hydra-define+ my/help-gnu-emacs (:foreign-keys warn :title my/help-gnu-emacs--title :quit-key "SPC")
      ("Emacs"
       (("d" view-emacs-debugging "How to debug emacs")
        ("P" view-external-packages "Where to get packages")
        ("r" info-emacs-manual)
        ("P" describe-package)
        ("p" finder-by-keyword "Find packages matching a given keyword")
        ("L" describe-language-environment)
        ("h" view-hello-file)
        ("I" describe-input-method)
        ("s" describe-syntax)
        ("F" view-emacs-FAQ "FAQ")
        ("t" help-with-tutorial "Tutorial")
        ("n" view-emacs-news "News")
        ("p" view-emacs-problems "Info on known emacs problems")
        ("t" view-emacs-todo "Todos"))))

    (message "Attaching hydra to leader - GNU Emacs")
    (pretty-hydra-define+ my/hydra-leader ()
      ("Misc"
       (("E" (my/help-gnu-emacs/body) "About Emacs" :color blue)))))
#+end_src
***** Help for gnu
#+begin_src emacs-lisp
  (with-eval-after-load 'all-the-icons
    (defvar my/help-gnu--title (all-the-icons-fileicon "gnu" "Help - Gnu" 1 -0.05))

    (pretty-hydra-define+ my/help-gnu (:foreign-keys warn :title my/help-gnu--title :quit-key "SPC")
      ("Gnu Project"
       (("e" about-emacs "About emacs")
        ("g" describe-gnu-project "Browse online information on the Gnu project")
        ("c" describe-copying "Describe copying")
        ("l" describe-distribution "How to get the latest emacs")
        ("w" describe-no-warranty "Warranty")))))
#+end_src

**** emacs-guix
#+begin_src emacs-lisp
  (with-eval-after-load 'major-mode-hydra
    (pretty-hydra-define+ my/hydra-leader ()
      ("Tools" (("g" (guix-popup) "Guix" :color blue)))))
#+end_src
**** Notes
***** Quick Capture
An inbox for reminders of ideas or meetings that will be processed later on, or trashed.

| Add a note to a file           | org-roam-find-file        |
| Force db cache refresh         | org-roam-db-rebuild-cache |
| Link to another org document   | org-roam-insert           |
| Show backlinks to current note | org-roam                  |
| Visualize links                |                           |
| Add tag                        |                           |
| Add title                      |                           |
***** Permanent Notes 
****** Literature notes
Brief annotations on a particular source, there's a link between the source and the note.
****** Concept notes
These are independent notes, they need to be self-explanatory and detailed.

** Hercules - Never need to write another hydra again!
https://gitlab.com/jjzmajic/hercules.el
https://github.com/abo-abo/hydra/wiki
#+begin_src emacs-lisp
  (use-package hercules :after hydra)
#+end_src

*** COMMENT Evil window map
#+begin_src emacs-lisp
  (defhydra my/window-hydra ())

  (general-def :states '(normal motion) "C-w" 'my/window-hydra)
#+end_src

*** COMMENT Babel map
Can evil-window-map be more hydra-like
#+begin_src emacs-lisp
  (hercules-def
   :toggle-funs #'my/org-babel-mode
   :hide-funs '(org-babel-tangle)
   :keymap 'org-babel-map
   :transient t)

  (define-key org-mode-map (kbd "C-c C-v") #'my/org-babel-mode)
#+end_src

* Appearance and UI modifications
** yes/no => y/n
Kiss, right?
#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src
** Bell
I'm not a big fan of noise, but I do like the visible bell
#+begin_src emacs-lisp
  (setq visible-bell t)
  (setq ring-bell-function nil)
#+end_src
** Cursor blinking
I find a blinking cursor can be distracting
#+begin_src emacs-lisp 
  (blink-cursor-mode 0)
#+end_src
** Dialog boxes
I don't think dialog boxes are my style.
#+begin_src emacs-lisp
  (setq use-dialog-box nil)
#+end_src
** Frame transparency
#+begin_src emacs-lisp
  (set-frame-parameter (selected-frame) 'alpha '(100 . 100))
  (add-to-list 'default-frame-alist '(alpha . (100 . 100)))
  (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src
** Icons
#+begin_src emacs-lisp
  (use-package all-the-icons :delight)
#+end_src
** Line numbers
I prefer line numbers in most modes for pair programming etc, but have found enabling them on a per-mode basis rather than globally works best.
#+begin_src emacs-lisp
  (global-display-line-numbers-mode 0)
  (dolist (mode '(elisp-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 1))))
#+end_src
** Parenthesis colour matching
#+begin_src emacs-lisp 
  (use-package rainbow-delimiters
    :delight
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** Scrolling
One line at a time.
#+begin_src emacs-lisp
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
#+end_src
Don't accelerate scrolling
#+begin_src emacs-lisp
  (setq mouse-wheel-progressive-speed nil)
#+end_src
Scroll window under mouse
#+begin_src emacs-lisp
  (setq mouse-wheel-follow-mouse 't)
#+end_src
Keyboard scroll one line at a time
#+begin_src emacs-lisp
  (setq scroll-step 1)
#+end_src
** Org related UI tweaks
TIP: use describe-face org- if you think something isn't looking its best

#+begin_src emacs-lisp
    (defun my/org-apply-ui ()
      (interactive)
      (with-eval-after-load 'org
        (org-indent-mode) ; indent text according to outline structure
        ;(auto-fill-mode 0) ; don't automatically break lines exceeding current-fill-column
        (visual-line-mode 1) ; instead of breaking lines exceeding current-fill-column, visually wrap them

        (customize-set-variable 'org-ellipsis " ➠")
        (customize-set-variable 'org-hide-emphasis-markers t)
        (customize-set-variable 'evil-auto-indent nil)
        (customize-set-variable 'org-src-window-setup 'current-window
                                "open org-src blocks in current window")

    ;;; Replace list hyphen with dot
        ;; (font-lock-add-keywords 'org-mode
        ;;                         '(("^ *\\([-]\\) "
        ;;                            (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) " "))))))

        ))
#+end_src

*** Bullets
#+begin_src emacs-lisp
  (use-package org-bullets
    :delight
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom (org-bullets-bullet-list '("➊" "➋" "➌" "➍" "➎" "➏" "➐" "➑" "➒")))
#+end_src
** Margins
#+begin_src emacs-lisp
  (setq-default fringes-outside-margins t)
  (setq-default left-margin-width 1)
  (setq-default right-margin-width 1)
#+end_src
** Fonts
#+begin_src emacs-lisp
;(set-frame-font "Fantasque Sans Mono-14" nil t)
;(set-frame-font "Source Code Pro-14" nil t)
  ;(defvar my/fixed-pitch-font "Noto Mono")
  ;(defvar my/fixed-pitch-height 110)
  ;(defvar my/variable-pitch "Cantarell")
  ;(defvar my/variable-pitch-height 160)
#+end_src

** Modeline
*** COMMENT smart modeline
#+begin_src emacs-lisp
  (use-package smart-mode-line
    :after smart-mode-line-powerline-theme

    :init
    (setq sml/no-confirm-load-theme t)
    (setq sml/vc-mode-show-backend t)

    :config
    (sml/setup)
    ;(sml/apply-theme 'light-powerline)
    )
#+end_src
*** Move modeline to the top
#+begin_src emacs-lisp
  ;(setq-default header-line-format mode-line-format)
  ;(setq-default mode-line-format nil)
#+end_src
** Theme
*** Theme loading functions
https://www.brautaset.org/articles/2017/hydra-theme-switcher.html
**** Disable all themes
#+begin_src emacs-lisp
  (defun sb/disable-all-themes ()
    (interactive)
    (mapc #'disable-theme custom-enabled-themes))
#+end_src
**** Load theme
#+begin_src emacs-lisp
  (defun sb/load-theme (theme)
    "Enhance `load-theme' by first disabling enabled themes."
    (sb/disable-all-themes)
    (load-theme theme t)
    (sml/apply-theme 'light-powerline))
#+end_src
**** A theme switching hydra
#+begin_src emacs-lisp
  (setq sb/hydra-selectors
        "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")

  (defun sb/sort-themes (themes)
    (sort themes
          (lambda (a b)
            (string<
             (symbol-name a)
             (symbol-name b)))))

  (defun sb/hydra-load-theme-heads (themes)
    (mapcar* (lambda (a b)
               (list (char-to-string a)
                     `(sb/load-theme ',b)
                     (symbol-name b)))
             sb/hydra-selectors themes))

  (defun populate-theme-hydra ()
    (interactive)
    (eval `(defhydra sb/hydra-select-themes
             (:hint nil :color pink)
             "Select Theme"
             ,@(sb/hydra-load-theme-heads
                (sb/sort-themes
                 (custom-available-themes)))
             ("DEL" (sb/disable-all-themes))
             ("RET" nil "done" :color blue))))

  (with-eval-after-load 'major-mode-hydra
    (pretty-hydra-define+ my/hydra-leader ()
      ("Misc"
       (("t" (progn 
               (populate-theme-hydra)
               (sb/hydra-select-themes/body)) 
         "change theme" :color blue)))))
#+end_src

*** COMMENT Smart mode line powerline theme
#+begin_src emacs-lisp
  (use-package smart-mode-line-powerline-theme)
#+end_src

*** COMMENT Apply a doom theme
#+begin_src emacs-lisp
  (use-package doom-themes
    :after smart-mode-line
    :delight
    :config
                                          ;(load-theme 'doom-snazzy t
                                          ;(load-theme 'doom-manegarm t
                                          ;(load-theme 'whiteboard t)
                                          ;(load-theme 'doom-sourcerer t)
    (sb/load-theme 'doom-one-light))
#+end_src

*** COMMENT Moody modeline
#+begin_src emacs-lisp
  (use-package moody
    :config
    (setq x-underline-at-descent-line t)
    (moody-replace-mode-line-buffer-identification)
    (moody-replace-vc-mode))
#+end_src

*** Apply modus theme
https://protesilaos.com/modus-themes/
#+begin_src emacs-lisp
  (use-package modus-themes
    :ensure
    ;:after (moody)
    :init
    ;; Add all you customizations priot to loading the themes
    (setq modus-themes-italit-constructs t
          modus-themes-success-deuteranopia t
          modus-themes-bold-constructs t
          modus-themes-italic-constructs t
          modus-themes-links '(neutral-underline faint background)
          modus-themes-prompts '(intense background gray)
          modus-themes-mode-line '(moody borderless accented)
          face-near-same-color-threshold 70000
          x-underline-at-descent-line t
          modus-themes-completions 'opinionated
          modus-themes-fringes 'intense
          modus-themes-lang-checkers '(straight-underline)
          modus-themes-hl-line '(accented)
          modus-themes-subtle-line-numbers t
          modus-themes-paren-match '(intense underline)
          modus-themes-region '(bg-only no-extend)
          modus-themes-diffs '(bg-only)
          modus-themes-org-blocks 'tinted-background
          org-src-fontify-natively t
          org-fontify-quote-and-verse-blocks t
          modus-themes-org-agenda
          '((header-block . (variable-pitch scale-title))
            (header-date . (grayscale workaholic bold-today))
            (scheduled . uniform)
            (habit . traffic-light))
          modus-themes-headings
          '((1 . (background overline))
            (2 . (overline rainbow))
            (t . (monochrome)))
          modus-themes-scale-headings t
          modus-themes-scale-1 1.05
          modus-themes-scale-2 1.1
          modus-themes-scale-3 1.15
          modus-themes-scale-4 1.2
          modus-themes-scale-title 1.3
          )

    ;; Main typeface
    (set-face-attribute 'default nil :family "DejaVu Sans Mono" :height 110)

    ;; Proportionately spaced typeface
    (set-face-attribute 'variable-pitch nil :family "DejaVu Serif" :height 1.0)

    ;; Monospaced typeface
    (set-face-attribute 'fixed-pitch nil :family "DejaVu Sans Mono" :height 1.0)

    ;; Load the theme files before enabling a theme
    (modus-themes-load-themes)
    :config
    ;; Load the theme of your choice:
    (modus-themes-load-operandi) ;; OR (modus-themes-load-vivendi)
    (hl-line-mode)
    (show-paren-mode)

  (setq-default header-line-format mode-line-format)
    :bind ("<f5>" . modus-themes-toggle))
#+end_src

** Completion UI - Icomplete vertical
#+begin_src emacs-lisp
  (use-package icomplete-vertical
    :demand t
    :custom
    (completion-styles '(partial-completion substring))
    (completion-category-overrides '((file (styles basic substring))))
    (read-file-name-completion-ignore-case t)
    (read-buffer-completion-ignore-case t)
    (completion-ignore-case t)
    :config
    (icomplete-mode)
    (icomplete-vertical-mode)
    :bind (:map icomplete-minibuffer-map
                ("<down>" . icomplete-forward-completions)
                ("C-n" . icomplete-forward-completions)
                ("<up>" . icomplete-backward-completions)
                ("C-p" . icomplete-backward-completions)
                ("C-v" . icomplete-vertical-toggle)))
#+end_src

** COMMENT Minibuffer
https://github.com/raxod502/selectrum/wiki/Additional-Configuration#display-minibuffer-in-a-child-frame-with-mini-frame
#+begin_src emacs-lisp
  (use-package mini-frame
    :custom
    ((mini-frame-show-parameters ((top . 10)
                                 (width . 0.7)
                                 (left . 0.5))))

    :config
    (setq x-gtk-resize-child-frames 'resize-mode)
    (mini-frame-mode +1))
#+end_src

* Behaviour

** Incremental narrowing
#+begin_src emacs-lisp
  (use-package selectrum
    :config
    (selectrum-mode +1))

  (use-package selectrum-prescient
    :after (selectrum)
    :config
    (selectrum-prescient-mode +1)
    (prescient-persist-mode +1))
#+end_src

** Completion
*** Consult
https://github.com/minad/consult
#+begin_src emacs-lisp
  (use-package consult)
#+end_src

*** Vertico
https://github.com/minad/vertico
#+begin_src emacs-lisp
  (use-package vertico
    :init
    (vertico-mode))
#+end_src

** Acting on targets
https://github.com/oantolin/embark/
#+begin_src emacs-lisp
  (use-package embark
    :ensure t

    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

    :init

    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    :config

    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :ensure t
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** Annotations
https://github.com/minad/marginalia
#+begin_src emacs-lisp
;; Enable richer annotations using the Marginalia package
(use-package marginalia
  ;; Either bind `marginalia-cycle` globally or only in the minibuffer
  :bind (("M-A" . marginalia-cycle)
         :map minibuffer-local-map
         ("M-A" . marginalia-cycle))

  ;; The :init configuration is always executed (Not lazy!)
  :init

  ;; Must be in the :init section of use-package such that the mode gets
  ;; enabled right away. Note that this forces loading the package.
  (marginalia-mode))
#+end_src

* Help enhancements
  Requires the emacswiki.org git repo to be checked out.

  git clone git://github.com/emacsmirror/emacswiki.org.git emacswiki
  git checkout -b master origin/master

** help-macro+
#+begin_src emacs-lisp
  (use-package help-macro+ :straight (:type git :host github :repo "emacsmirror/help-macro-plus"))
#+end_src

** help-fns+
#+begin_src emacs-lisp
  (use-package help-fns+ :straight (:type git :host github :repo "emacsmirror/help-fns-plus"))
#+end_src

** help-find
#+begin_src emacs-lisp
  (use-package help-find :straight (:type git :host github :repo "emacsmirror/help-find"))
#+end_src
* Org-mode
#+begin_src emacs-lisp
    (with-eval-after-load 'all-the-icons
      (with-eval-after-load 'major-mode-hydra
        (use-package org
          :delight
          :straight (:type built-in)
          :preface
          (defun my/org-mode-setup ()
            (my/org-apply-ui)
            <<org-agenda-files>>
            <<org-refile-targets>>
            )
          :hook ((org-mode . my/org-mode-setup))
          :mode-hydra 
          (org-mode
           ("Clock"
            (("t" org-timer-start)
             ("s" org-timer-stop)
             ;; Need to be at timer
             ("r" org-timer-set-timer)
             ;; Print timer value to buffer
             ("p" org-timer)
             ("w" (org-clock-in '(4)))
             ("o" org-clock-out)
             ;; Visit the clocked task from any buffer
             ("j" org-clock-goto)
             ("c" org-capture)
             ("l" org-capture-goto-last-stored))
           "Move"
            (("h" org-previous-visible-heading :color red)
             ("j" org-forward-element :color red)
             ("k" org-backward-element :color red)
             ("l" org-next-visible-heading :color red))))
          :config
          (setq org-log-into-drawer t)
          (require 'ox-org)
          :custom
          (org-catch-invisible-edits 'smart)
          <<custom-org-babel>>
          <<custom-org-diary>>
          <<custom-org-notes>>
          )))
#+end_src
*** Org capture templates
#+begin_src emacs-lisp
  (setq org-capture-templates
        '(("r" "Risk" table-line (file+headline (lambda () (buffer-file-name)) "Risks") "|id|%u|%?||")
          ("a" "Assumption" table-line (file+headline (lambda () (buffer-file-name)) "Assumptions") "")
          ("i" "Issue" table-line (file+headline (lambda () (buffer-file-name)) "Issues") "")
          ("d" "Decision" table-line (file+headline (lambda () (buffer-file-name)) "Decisions") "")
          ("t" "Task" entry (file+headline (lambda () (buffer-file-name)) "Tasks") "** TODO %^{Description}%?\n:LOGBOOK:\n- Added: %U\n:END:")
          ("m" "Meeting" entry (file+headline (lambda () (buffer-file-name)) "Meeting")
           "")
          ))

#+end_src
** org-roam
https://www.orgroam.com/manual.html
Installation
#+begin_src emacs-lisp
  (use-package org-roam
    :custom 
    (org-roam-directory my/org-roam-directory)
    (org-roam-capture-templates my/org-roam-capture-templates)

    :init
    (setq org-roam-v2-ack t)

    :hook
    (after-init . org-roam-mode)

    :config
    (org-roam-setup))
#+end_src
*** Templates
- [ ] https://takeonrules.com/2020/12/08/revisiting-hydra-menu-for-org-roam-lookup-in-emacs/
Progfolio/doct

Everything starts with an idea.
I can either use org-capture (org)Capture
or, (org-roam)Daily-notes
Either way, this will be an inbox for processing later. In a gtd sense.
I'm going to lean towards using org-roam for things like capture templates.


#+begin_src emacs-lisp
  (defvar my/org-roam-capture-templates
    '(("d" "default" plain
       "%?"
       :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}") :unnarrowed t)
      ("l" "Programming language" plain
       "* Characteristics\n\n- Family: %?\n- Inspired by: \n\n* Reference:\n\n"
       :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}") :unnarrowed t)
      ("p" "Project" plain
       (file "~/roam/Templates/Project.org")
       :if-new (file+head "%<%y%m%d%h%m%s>-${slug}.org" "#+title: project: ${title}\n#+filetags: project") :unnarrowed t)
      ("m" "Meeting" plain
       (file "~/roam/Templates/Meeting.org")
       :if-new (file+head "%<%y%m%d%h%m%s>-${slug}.org" "#+title: project: ${title}\n#+filetags: project") :unnarrowed t)
      ))
#+end_src

#+begin_src emacs-lisp :noweb-ref org-roam-daily-templates
  (setq org-roam-dailies-capture-templates
        '(("d" "default" entry
           "* %?"
           :if-new (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>"))))
#+end_src

**** Projects
Projects make use of :DEADLINE and :SCHEDULED: properties, they are captured in the timeline in a column view.

#+begin_src org :tangle ~/roam/Templates/Project.org
  ,* Description
  ,* Project goals
  ,* Timeline
  Elements with :SCHEDULED: or :DEADLINE: properties are gathered here.
  ,#+BEGIN: columnview :hlines 1 :id "label" :match "TODO,DEADLINE,SCHEDULED"
  ,#+END:
  ,* Risks
  | ID | Captured On | Description | Mitigation |
  |----+-------------+-------------+------------|
  |    |             |             |            |
  ,* Assumptions
  | ID | Captured On | Description | Mitigation |
  |----+-------------+-------------+------------|
  |    |             |             |            |
  ,* Issues
  | ID | Captured On | Description | Mitigation |
  |----+-------------+-------------+------------|
  |    |             |             |            |
  ,* Decisions
  | ID | Captured On | Description | Mitigation |
  |----+-------------+-------------+------------|
  |    |             |             |            |
  ,* Meetings
  ,* Tasks
#+end_src

**** Project meeting
#+begin_src org :tangle ~/roam/Templates/Meeting.org
  ,* Attendees
  ,* Actions
  ,* Notes
#+end_src

** org-babel
*** Don't confirm
#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src
*** Plantuml
#+begin_src emacs-lisp
  (use-package plantuml-mode
    :after org
    :config
    (setq org-plantuml-jar-path (expand-file-name "/home/user/.guix-profile/bin/plantuml"))
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t)))
  )
#+end_src
*** Languages
I'd like to be able to see results from shell scripts etc. in my org buffers
#+begin_src emacs-lisp :noweb-ref custom-org-babel :tangle no
  (setq org-babel-load-languages
   '(
     ;; (Awk . t)
     ;; (C . t)
     ;; (Ditaa . t)
     ;; (Dot . t)
     (emacs-lisp . t)
     ;; (Java . t)
     ;; (Javascript . t)
     ;; (Lisp . t)
     ;; (Python . t)
     (plantuml . t)
     ;; (Ruby . t)
     ;; (Scheme . t)
     (shell . t)
     ;; (SQL . t)
     ;; (Sqlite . t)
     ))
#+end_src
*** Templates
Org mode template keywords, like 

| Example | Result                 |
|---------+------------------------|
| <el     | #+begin_src emacs-lisp |
| <sh     | #+begin_src shell      |
| <I      | #+include: "guix.org"  |
| <L      | #+latex:               |
| <H      | #+html:                |
| <A      | #+ascii:               |
| <i      | #+index:               |

#+begin_src emacs-lisp
  (use-package org-tempo
    :delight
    :straight (:type built-in)
    :config
    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("py" . "src python")))
#+end_src
*** Async
When I'm running those blocks, I'd like the option for them to run async
#+begin_src emacs-lisp
  (use-package ob-async
    :delight
    :config
    (setq ob-async-no-async-languages-alist '("ipython")))
#+end_src
*** Hercules
#+begin_src emacs-lisp
  (hercules-def
   :toggle-funs #'org-babel-mode
   :keymap 'org-babel-map
   :transient t)

  (define-key org-mode-map (kbd "C-c C-v") #'org-babel-mode)
#+end_src
** Agenda / Super Agenda
*** These are the files that are used to build the agenda
https://orgmode.org/manual/Agenda-Files.html#Agenda-Files
The files to be used for the agenda display
#+begin_src emacs-lisp :noweb-ref org-agenda-files
  (setq org-agenda-files
        (append 
         `(,my/org-roam-directory)
         `(,my/org-roam-dailies-directory)
                                          ;'("~/org/agenda")
                                          ;(file-expand-wildcards "~/Projects/*/*.org")
                                          ;FIXME, projects will differ on other boxes, link this to projectile instead of hard-coding
                                          ;(file-expand-wildcards "~/*/*.org")
         ))
#+end_src
*** COMMENT Diary file
Name of the file in which one's personal diary of dates is kept.
   File to which to add new entries with the ‘i’ key in agenda and calendar.
#+begin_src emacs-lisp :noweb-ref custom-org-diary :tangle no
  ;(org-agenda-diary-file "~/org/diary")
#+end_src
*** COMMENT org-super-agenda
This does not collect items, it only groups items that are collected by Org Agenda or org-ql
https://github.com/alphapapa/org-super-agenda
https://github.com/alphapapa/org-super-agenda/blob/master/examples.org
#+begin_src emacs-lisp
  (use-package org-super-agenda
    :delight
    ;:hook (org-mode . org-super-agenda-mode)
    :custom
    (org-super-agenda-groups
     '(;; Each group has an implicit boolean OR operator between its selectors.
       (:name "Today"  ; Optionally specify section name
              :time-grid t  ; Items that appear on the time grid
              :todo "TODAY")  ; Items that have this TODO keyword
       (:name "Important"
              ;; Single arguments given alone
              :tag "bills"
              :priority "A")
       ;; Set order of multiple groups at once
       (:order-multi (2 (:name "Shopping in town"
                               ;; Boolean AND group matches items that match all subgroups
                               :and (:tag "shopping" :tag "@town"))
                        (:name "Food-related"
                               ;; Multiple args given in list with implicit OR
                               :tag ("food" "dinner"))
                        (:name "Personal"
                               :habit t
                               :tag "personal")
                        (:name "Space-related (non-moon-or-planet-related)"
                               ;; Regexps match case-insensitively on the entire entry
                               :and (:regexp ("space" "NASA")
                                             ;; Boolean NOT also has implicit OR between selectors
                                             :not (:regexp "moon" :tag "planet")))))
       ;; Groups supply their own section names when none are given
       (:todo "WAITING" :order 8)  ; Set order of this section
       (:todo ("SOMEDAY" "TO-READ" "CHECK" "TO-WATCH" "WATCHING")
              ;; Show this group at the end of the agenda (since it has the
              ;; highest number). If you specified this group last, items
              ;; with these todo keywords that e.g. have priority A would be
              ;; displayed in that group instead, because items are grouped
              ;; out in the order the groups are listed.
              :order 9)
       (:priority<= "B"
                    ;; Show this section after "Today" and "Important", because
                    ;; their order is unspecified, defaulting to 0. Sections
                    ;; are displayed lowest-number-first.
                    :order 1)
       ;; After the last group, the agenda will display items that didn't
       ;; match any of these groups, with the default order position of 99
       :config
       (org-super-agenda-mode)
  )))
#+end_src
** COMMENT Re-filing
#+begin_src emacs-lisp :noweb-ref org-refile-targets
  (setq org-refile-targets
        '((nil :maxlevel . 1)
          (org-agenda-files :maxlevel .1)))
#+end_src
** COMMENT org-noter
#+begin_src emacs-lisp
  (use-package org-noter
    :delight)
#+end_src
*** COMMENT Notes
#+begin_src emacs-lisp :noweb-ref custom-org-notes :tangle no
  (org-agenda-default-notes-file "~/org/notes")
#+end_src
** COMMENT Drill
** COMMENT org-sidebar
#+begin_src emacs-lisp
  (use-package org-sidebar
    :delight
    :preface
    (defun my/org-today-sidebar (source-buffer)
      (let ((display-buffer
             (generate-new-buffer (format "TODAY org-sidebar<%s>" (buffer-name source-buffer))))
            (title (propertize (concat "Today's deadlines in: " (buffer-name source-buffer))
                               'help-echo "Items to-do today")))
        (with-current-buffer display-buffer
          (setf org-sidebar-source-buffer source-buffer))
        (save-window-excursion
          ;; `org-ql-search' displays the buffer, but we don't want to do that here.
          (org-ql-search source-buffer
            '(and (not (done))
                  (or (scheduled :to today) (deadline :to today))) ; should be scheduled today / deadline today
	  
            :narrow t
            :sort '(priority date)
            :super-groups '((:auto-todo))
            :buffer display-buffer
            :title title))
        display-buffer))
  
    ;; (defun my/org-today-sidebar ()
    ;; "Show my Org Today Sidebar."
    ;; (interactive)
    ;; (org-sidebar
    ;; :sidebars (make-org-sidebar
    ;; 		:name "Today"
    ;; 		:description "Today items"
    ;; 		:items (org-ql (org-agenda-files)
    ;; 			(and (not (done))
    ;; 				(or (deadline auto)
    ;; 				    (scheduled :to today)))
    ;; 			:action element-with-markers)
    ;; 		:super-groups '((:time-grid t)
    ;; 				(:name "Overdue" :scheduled past :deadline past)
    ;; 				(:name "Due today" :scheduled today :deadline today)
    ;; 				(:tag "bills")
    ;; 				(:priority "A")
    ;; 				(:name "Non-tasks"
    ;; 					:todo nil)))))
  
    :custom
    (org-sidebar-side 'left)
    (org-sidebar-default-fns '(org-sidebar-tree-view-buffer
                               my/org-today-sidebar
                               org-sidebar--upcoming-items
                               org-sidebar--todo-items))
    :bind (([M-tab] . org-sidebar-toggle))
                                          ; :hook (org-mode . my/org-today-sidebar)
  )
#+end_src
** COMMENT Habit
https://orgmode.org/manual/Tracking-your-habits.html
There are 2 things needed to make a habit. 1.) Schedule a todo item with a repeater. 2.) Give the item the habit property.

You can make habits visible in the org agenda using K

I prefer to put all my habits into a single file.

#+begin_src emacs-lisp
  (defconst my/habitfile "~/org/habit.org")
#+end_src
** COMMENT Journal
** COMMENT org-ref
https://github.com/jkitchin/org-ref
** COMMENT org-download
#+begin_src emacs-lisp
  (use-package org-download
    :delight
    :after org
    :bind
    (:map org-mode-map
          (("s-Y" . org-download-screenshot)
           ("s-y" . org-download-yank))))
#+end_src
** TODO org-webring
* leetcode
#+begin_src emacs-lisp
  (use-package leetcode
    :config
      ;(setq leetcode-prefer-language "python3")
      (setq leetcode-prefer-language "javascript")
      (setq leetcode-prefer-sql "mysql")
      (setq leetcode-save-solutions t)
      (setq leetcode-directory "~/leetcode"))
#+end_src

* Git / version management / magit
https://lists.gnu.org/archive/html/emacs-devel/2016-01/msg01802.html
#+begin_src emacs-lisp 
  (use-package magit
    :delight
    :custom (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
    :config
    (start-process "git-fsck" nil "git" "git" "config" "--global" "transfer.fsckObjects" "true") 
    (start-process "git-config-github-user" nil "git" "git" "config" "--global" "github.user" "bluekeys" "true") 
    ;(start-process "git-config-email" nil "git" "git" "config" "--global" "user.email" "user@example.com") 
    ;(start-process "git-config-email" nil "git" "git" "config" "--global" "user.name" "user")
    ;(my/leader-key-def "m" '(magit :which-key "magit"))

    (with-eval-after-load 'general
      (pretty-hydra-define+ my/hydra-leader ()
        ("Tools"
         (("m" (magit-status) "Magit" :color blue))))))
#+end_src
** Forge
https://github.com/magit/forge

Tokens on github can be review https://github.com/settings/tokens
#+begin_src emacs-lisp
  (use-package forge :after magit) ; create a token on github and put it in .authinfo
#+end_src
** COMMENT Dired git
https://github.com/conao3/dired-git.el
#+begin_src emacs-lisp
  (use-package dired-git
    :init (promise-rejection-tracking-enable '((all-rejections . t)))
    :after (all-the-icons)
    :hook (dired-mode . dired-git-mode))
#+end_src
** Dired git info
#+begin_src emacs-lisp
  (use-package dired-git-info
    :init
    (with-eval-after-load 'dired
      (setq dgi-auto-hide-details-p nil)
      (define-key dired-mode-map ")" 'dired-git-info-mode)))
#+end_src
** diff-hl
#+begin_src emacs-lisp
  (use-package diff-hl
    :config
    (global-diff-hl-mode)
  ;; (let* ((height (frame-char-height))
  ;;        (width 2)
  ;;        (ones (1- (expt 2 width)))
  ;;        (bits (make-vector height ones)))
  ;;   (define-fringe-bitmap 'my-diff-hl-bitmap bits height width))
  ;; (setq diff-hl-fringe-bmp-function (lambda (type pos) 'my-diff-hl-bitmap))
    )
#+end_src

** COMMENT Git Gutter
https://github.com/emacsorphanage/git-gutter
#+begin_src emacs-lisp
  (use-package git-gutter
    :defer t
    :hook ((markdown-mode . git-gutter-mode)
           (prog-mode . git-gutter-mode)
           (conf-mode . git-gutter-mode))
    :init
    :config
    (setq git-gutter:disabled-modes '(asm-mode image-mode)
          git-gutter:update-interval 1
          git-gutter:window-width 2
          git-gutter:ask-p nil)

    (defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1)
                           :hint nil)
      "
   Git gutter:
     _j_: next hunk        _s_tage hunk     _q_uit
     _k_: previous hunk    _r_evert hunk    _Q_uit and deactivate git-gutter
     ^ ^                   _p_opup hunk
     _h_: first hunk
     _l_: last hunk        set start _R_evision
   "
      ("j" git-gutter:next-hunk)
      ("k" git-gutter:previous-hunk)
      ("h" (progn (goto-char (point-min))
                  (git-gutter:next-hunk 1)))
      ("l" (progn (goto-char (point-min))
                  (git-gutter:previous-hunk 1)))
      ("s" git-gutter:stage-hunk)
      ("r" git-gutter:revert-hunk)
      ("p" git-gutter:popup-hunk)
      ("R" git-gutter:set-start-revision)
      ("q" nil :color blue)
      ("Q" (progn (git-gutter-mode -1)
                  ;; git-gutter-fringe doesn't seem to
                  ;; clear the markup right away
                  (sit-for 0.1)
                  (git-gutter:clear))
       :color blue)))

#+end_src

** COMMENT Git gutter fringe
#+begin_src emacs-lisp
  (use-package git-gutter-fringe
    :diminish git-gutter-mode
    :after git-gutter
    :demand fringe-helper
    :config
    ;; subtle diff indicators in the fringe
    ;; places the git gutter outside the margins.
    (setq-default fringes-outside-margins t)
    ;; thin fringe bitmaps
    (define-fringe-bitmap 'git-gutter-fr:added
      [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
      nil nil 'center)
    (define-fringe-bitmap 'git-gutter-fr:modified
      [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
      nil nil 'center)
    (define-fringe-bitmap 'git-gutter-fr:deleted
      [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
      nil nil 'center))
#+end_src
** TODO evil-magit
#+begin_src emacs-lisp
  ; (use-package evil-magit :after magit)
#+end_src
** TODO ghub
#+begin_src emacs-lisp
  ; (use-package ghub
  ; )
#+end_src
** TODO magit-todos
* Flashcards
I'm going to try org-fc instead of org-drill for now. No particular reason.
https://www.leonrische.me/fc/index.html
#+begin_src emacs-lisp 
  (use-package org-fc
    :after hydra
    :straight (org-fc
               :type git
               :repo "https://git.sr.ht/~l3kn/org-fc"
               :files (:defaults "awk" "demo.org"))

    :init
    (setq org-fc-directories `(,my/org-roam-directory))
    (setq org-fc-review-history-file "~/flashcard-review-history.tsv")

    :config
    (require 'org-fc-hydra)
    (require 'org-fc-keymap-hint)

    (pretty-hydra-define+ my/hydra-leader ()
      ("Misc" (("F" org-fc-hydra/body "Flashcards" :color blue))))

    (evil-define-minor-mode-key '(normal insert emacs) 'org-fc-review-flip-mode
      (kbd "RET") 'org-fc-review-flip
      (kbd "n") 'org-fc-review-flip
      (kbd "s") 'org-fc-review-suspend-card
      (kbd "q") 'org-fc-review-quit)

    (evil-define-minor-mode-key '(normal insert emacs) 'org-fc-review-rate-mode
      (kbd "a") 'org-fc-review-rate-again
      (kbd "h") 'org-fc-review-rate-hard
      (kbd "g") 'org-fc-review-rate-good
      (kbd "e") 'org-fc-review-rate-easy
      (kbd "s") 'org-fc-review-suspend-card
      (kbd "q") 'org-fc-review-quit))
#+end_src

* Dashboard
https://github.com/emacs-dashboard/emacs-dashboard 

This is the first thing I see when I switch on my laptop. I would like it to be very focussed.

Ideally, I would see a welcome message, goals according to priority

- [ ] No need for a logo
- [ ] No need for a welcome message, but something witty, inspirational or similar might be nice
- [ ] Goals clearly visible
- [ ] Tasks, prioritised and visible
- [ ] Upcoming appointments
- [ ] Maybe emacs packages loaded in x time message
- [ ] Maybe links to my site or github

** Inhibit the standard emacs startup screen
This will show Dashboard in frames created with emacsclient -c

#+begin_src emacs-lisp
  (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
#+end_src

** Configure the dashboard
#+begin_src emacs-lisp
  (use-package dashboard
    :delight
    :custom (dashboard-page-separator "\n\n\n")
    :config
    (dashboard-setup-startup-hook)
    (setq dashboard-items '((agenda . 10)
                            (recents . 10)
                            (registers . 10)))
    (setq dashboard-set-init-info t)
    (setq dashboard-week-agenda t)
    (setq dashboard-org-agenda-categories '("Tasks" "Appointments"))
    (setq dashboard-filter-agenda-entry 'dashboard-filter-agenda-by-time)
    (setq dashboard-set-heading-icons t)
    (setq dashboard-agenda-release-buffers t)
    (setq dashboard-set-file-icons t)
    (setq dashboard-set-footer nil))
#+end_src
** Create a shortcut function to switch to the dashboard
#+begin_src emacs-lisp
  (defun my/dashboard-switch ()
    "Switch to dashboard and refresh content"
    (interactive)
    (switch-to-buffer "*dashboard*")
    (dashboard-refresh-buffer))

  (with-eval-after-load 'general
    (pretty-hydra-define+ my/hydra-leader ()
      ("Dashboard"
       (("D" (my/dashboard-switch) "Goto *dashboard*")))))
#+end_src
** Create a dashboard widget that shows un-filed captures
#+begin_src emacs-lisp
  (defun my/dashboard-insert-unfiled-org-captures (list-size)
    (insert "Un-filed captures"))

  (add-to-list 'dashboard-item-generators '(unfiled . my/dashboard-insert-unfiled-org-captures))
  (add-to-list 'dashboard-items '(unfiled) t)

  (dashboard-modify-heading-icons '((unfiled . "file-text")))
#+end_src
* COMMENT Improve help by including contextual info
** Helpful
https://github.com/Wilfred/helpful
Helpful is an alternative to the built-in Emacs help that provides much more contextual information.
#+begin_src emacs-lisp
  (use-package helpful
    :delight
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key)
    :pretty-hydra
    ((:color teal :quit-key "SPC")
     ("Helpful"
      ()))
    :bind ("C-h" . my/help/body))
#+end_src
** Which-key
#+begin_src emacs-lisp
  (use-package which-key
    :delight
    :config
    (setq which-key-idle-delay 0)
    (which-key-mode))
#+end_src
* COMMENT Search
** Buffers -> Swiper, any ivy enhanced alternative to isearch
http://pragmaticemacs.com/emacs/dont-search-swipe/
#+begin_src emacs-lisp 
  (use-package swiper
    :delight
    :after (ivy)
    :bind (("C-s" . swiper)
           ("C-r" . swiper)))
#+end_src

** Filesystem
Search and replace
https://sam217pa.github.io/2016/09/11/nuclear-power-editing-via-ivy-and-ag/
http://blog.binchen.org/posts/use-wgrep-and-evil-to-replace-text-efficiently.html
#+begin_src emacs-lisp 
  (use-package ag :delight)
  (use-package wgrep :delight)
#+end_src

* COMMENT Programming Language Support
** Play nice with HTML
Edit html like paredit
#+begin_src emacs-lisp 
  (use-package tagedit
    :delight)
#+end_src

** Lisp
*** Handle parenthesis with style - Paredit
Paredit makes handling lisp expressions much, much easier
Cheatsheet: http://www.emacswiki.org/emacs/PareditCheatsheet
#+begin_src emacs-lisp 
  (use-package paredit
    :delight
    :hook ((emacs-lisp-mode
            eval-expression-minibuffer-setup
            ielm-mode
            ;clojure-mode
            lisp-mode
            lisp-interaction-mode
            scheme-mode
            geiser-repl-mode) 
           . enable-paredit-mode)) 
#+end_src
*** TODO Clojure (for the brave!)
#+begin_src emacs-lisp 
  ;; key bindings and code colorization for Clojure
  ;; "When several buffers visit identically-named files,
  ;; Emacs must give the buffers distinct names. The usual method
  ;; for making buffer names unique adds ‘<2>’, ‘<3>’, etc. to the end
  ;; of the buffer names (all but one of them).
  ;; The forward naming method includes part of the file's directory
  ;; name at the beginning of the buffer name
  ;; https://www.gnu.org/software/emacs/manual/html_node/emacs/Uniquify.html
  ;; (use-package uniquify
  ;; :config
  ;; (setq uniquify-buffer-name-style 'forward))

  ;; https://github.com/clojure-emacs/clojure-mode
  ;; syntax hilighting for midje
;  (use-package clojure-mode
;    :delight
;    :config
;    (lambda ()
;      (setq inferior-lisp-program "lein repl")
;      (font-lock-add-keywords
;       nil
;       '(("(\\(facts?\\)"
;          (1 font-lock-keyword-face))
;         ("(\\(background?\\)"
;          (1 font-lock-keyword-face))))
;      (define-clojure-indent (fact 1))
;      (define-clojure-indent (facts 1))
;      (rainbow-delimiters-mode)))
;
;  ;; extra syntax highlighting for clojure
;  (use-package clojure-mode-extra-font-locking)

  ;; integration with a Clojure REPL
  ;; https://github.com/clojure-emacs/cider
  (use-package cider
    :delight
    :config
    ;; provides minibuffer documentation for the code you're typing into the repl
    (add-hook 'cider-mode-hook 'eldoc-mode)

    ;; go right to the REPL buffer when it's finished connecting
    (setq cider-repl-pop-to-buffer-on-connect t)

    ;; When there's a cider error, show its buffer and switch to it
    (setq cider-show-error-buffer t)
    (setq cider-auto-select-error-buffer t)

    ;; Where to store the cider history.
    (setq cider-repl-history-file "~/.emacs.d/cider-history")

    ;; Wrap when navigating history.
    (setq cider-repl-wrap-history t)

    ;; enable paredit in your REPL
    (add-hook 'cider-repl-mode-hook 'paredit-mode)

    ;; Use clojure mode for other extensions
    (add-to-list 'auto-mode-alist '("\\.edn$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("\\.boot$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("\\.cljs.*$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("lein-env" . enh-ruby-mode))
    ;; key bindings
    ;; these help me out with the way I usually develop web apps
  (defun cider-start-http-server ()
    (interactive)
    (cider-load-current-buffer)
    (let ((ns (cider-current-ns)))
      (cider-repl-set-ns ns)
      (cider-interactive-eval (format "(println '(def server (%s/start))) (println 'server)" ns))
      (cider-interactive-eval (format "(def server (%s/start)) (println server)" ns))))

  (defun cider-refresh ()
    (interactive)
    (cider-interactive-eval (format "(user/reset)")))

  (defun cider-user-ns ()
    (interactive)
    (cider-repl-set-ns "user"))

  (eval-after-load 'cider
    '(progn
       (define-key clojure-mode-map (kbd "C-c C-v") 'cider-start-http-server)
       (define-key clojure-mode-map (kbd "C-M-r") 'cider-refresh)
       (define-key clojure-mode-map (kbd "C-c u") 'cider-user-ns)
       (define-key cider-mode-map (kbd "C-c u") 'cider-user-ns))))
#+end_src
*** Emacs Lisp
#+begin_src emacs-lisp
  (major-mode-hydra-define+ emacs-lisp-mode nil
    ("Eval"
     (("b" eval-buffer "buffer")
      ("e" eval-defun "defun")
      ("r" eval-region "region"))
     "REPL"
     (("I" ielm "ielm"))
     "Test"
     (("t" ert "prompt")
      ("T" (ert t) "all")
      ("F" (ert :failed) "failed"))
     "Doc"
     (("d" helpful-at-point "thing-at-pt")
      ("f" describe-function "function")
      ("v" describe-variable "variable")
      ("i" info-lookup-symbol "info lookup"))))
#+end_src
*** Scheme
Install geiser, at the moment, I'm installing geiser-guile using guix.
Macrostep-geiser doesn't seem to be available atm either.

#+begin_src emacs-lisp
  (use-package geiser
    :custom
    (geiser-font-lock-repl-prompt 'nil)
    (geiser-font-lock-repl-input 'nil)
    :config
    )
#+end_src

** COMMENT EmacSQL
https://github.com/skeeto/emacsql
#+begin_src emacs-lisp
  (use-package emacsql
    :delight
    :straight (:built-in t))
#+end_src

#+begin_src emacs-lisp
  (use-package emacsql-sqlite
    :delight
    :straight (:built-in t))
#+end_src
* COMMENT File types
** PDF tools
https://github.com/politza/pdf-tools
http://pragmaticemacs.com/emacs/view-and-annotate-pdfs-in-emacs-with-pdf-tools/
#+begin_src emacs-lisp
  (use-package pdf-tools
    :delight
    ; :straight `,(if (eq window-system 'x) '(:type built-in) 't)
    :straight (:type built-in)
    :magic ("%PDF" . pdf-view-mode)
    :config
    ;; initialise
    (pdf-tools-install :no-query)
    ;; open pdfs scaled to fit page
    (setq-default pdf-view-display-size 'fit-page)
    ;; automatically annotate highlights
    (setq pdf-annot-activate-created-annotations t)
    ;; use normal isearch
    (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward))
#+end_src
** CSV mode
https://elpa.gnu.org/packages/csv-mode.html
#+begin_src emacs-lisp
  (use-package csv-mode
    :delight
    ;:straight (:type built-in)
  )
#+end_src
* COMMENT Perspective.el
 The most important thing when working on multiple things is to maintain perspective!
 https://github.com/nex3/perspective-el
 #+begin_quote
 Each perspective has its own buffer list and its own window layout. This makes it easy to work on many separate projects without getting lost in all the bffers. Switching to a perspective activates its window configuration, and when in a perspective, only its buffers are available (by default).

 Each emacs frame has a distinct list of perspectives.

 Perspective supports saving its state to a file, so long-lived work sessions may be saved and recovered as needed.
 #+end_quote

 #+begin_src emacs-lisp
   (use-package perspective
     :bind-keymap ("C-c p" . perspective-map)
     :delight
     :custom
     (persp-sort 'created)
     (persp-interactive-completion-function 'ivy-completing-read) ; breaks persp-sort
     (persp-state-default-file "perspective")
     :init
     ;(add-hook 'before-init-hook #'persp-state-load)
     :config
     (require 'bs)
     (persp-mode) ; To activate perspective use (persp-mode). This creates a single default main perspective
     (add-hook 'kill-emacs-hook #'persp-state-save)
     :bind (("C-x C-b" . (lambda (arg)
                           (interactive "P")
                           (if (fboundp 'persp-bs-show)
                               (persp-bs-show arg)
                             (bs-show "all")))) ; If given a prefix, show all
            ("C-x b" . persp-counsel-switch-buffer) ; counsel shows a preview of the buffer to switch to
            ("C-x k" . persp-kill-buffer*)))
 #+end_src
** Something recommended by perspective
 #+begin_src emacs-lisp
   (setq display-buffer-alist
         '((".*" (display-buffer-reuse-window display-buffer-same-window))))

   (setq display-buffer-reuse-frames t)         ; reuse windows in other frames
   (setq even-window-sizes nil)                 ; display-buffer: avoid resizing
 #+end_src
* COMMENT Projects / Projectile / Play nicely with projects
https://docs.projectile.mx/en/latest/
Configure projectile, perspective, persp-projectile and maybe shackle too.
#+begin_src emacs-lisp 
  (use-package projectile
    :bind-keymap ("C-c P" . projectile-command-map)
    :delight
    :custom ((projectile-completion-system 'ivy))
    :init
    (when (file-directory-p "~/projects")
      (setq projectile-project-search-path '("~/projects")))

    (when (eq (framep-on-display) 'w32)
      (setq projectile-project-search-path '("c:/projects")))

    (setq projectile-switch-project-action #'projectile-dired)
    :config (projectile-mode))

#+end_src
#+begin_src emacs-lisp
  (use-package counsel-projectile
    :delight
    :after (counsel projectile)
    :config (counsel-projectile-mode))
#+end_src
** COMMENT If I switch projects, all the workspaces should reflect that too
And the window focus and the buffer positions etc.
https://github.com/bbatsov/persp-projectile
#+begin_src emacs-lisp
  (use-package persp-projectile
    :delight
    :after (perspective projectile)
    ;:config (persp-mode)
)
#+end_src
* COMMENT notdeft
Could be used to search org-roam notes
https://tero.hasu.is/notdeft/
* COMMENT eReader
https://depp.brause.cc/nov.el/
#+begin_src emacs-lisp 
(use-package nov
  :delight
  :config
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  (setq nov-text-width 63))
#+end_src
** COMMENT Make nov behave like info
  Key  Purpose    
  [ and ]  Previous / next node    
  l and r  Go back / forward in history    
  n and p  Previous / next sibling node    
  u  Goes up one level to a parent node    
  SPC  Scroll one screen at a time    
  TAB  Cycles through cross-references and links    
  RET  Opens the active link    
  m  Prompts for a menu item name and opens    
    it    
  q  Closes the info browser    
* COMMENT bufler.el
* COMMENT show unstaged changes in the fringe
* COMMENT proced
https://www.emacswiki.org/emacs/ProcEd
* COMMENT Emacs rocks episode 11
https://github.com/swank-js/swank-js
* COMMENT EAF
https://emacsconf.org/2020/talks/34/
#+begin_src emacs-lisp
  (use-package eaf
    ;:load-path "~/.emacs.d/site-lisp/emacs-application-framework" ; Set to "/usr/share/emacs/site-lisp/eaf" if installed from AUR
    :init
    (use-package epc :defer t)
    (use-package ctable :defer t)
    (use-package deferred :defer t)
    (use-package s :defer t)
    :custom
    (eaf-browser-continue-where-left-off t)
    :config
    (eaf-setq eaf-browser-enable-adblocker "true")
    (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
    (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
    (eaf-bind-key take_photo "p" eaf-camera-keybinding)
    (eaf-bind-key nil "M-q" eaf-browser-keybinding)) ;; unbind, see more in the Wiki
#+end_src

* COMMENT EPC
#+begin_src emacs-lisp
  (use-package epc)
#+end_src

* COMMENT ctable
#+begin_src emacs-lisp
  (use-package ctable)
#+end_src

* COMMENT cl deprecation warnings
Emacs 27 and onward deprecates the built-in cl library (to be replaced with cl-lib). Emacs emits this warning whenever something, somewhere loads it at runtime. 
You can get a list of loaded packages that depend on cl by calling the following:
#+begin_src emacs-lisp
  (require 'loadhist)
  (file-dependents (feature-file 'cl))
#+end_src
